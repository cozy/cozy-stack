package crypto

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"errors"
	"time"
)

var (
	errMACTooLong = errors.New("mac: too long")
	errMACExpired = errors.New("mac: expired")
	errMACInvalid = errors.New("mac: the value is not valid")
)

const (
	macLen  = 32 // sha256 hash size
	timeLen = 8  // int64 for unix timestamp in seconds
)

// MACConfig contains all the options to encode or decode a message along with
// a proof of integrity and authenticity.
//
// Key is the secret used for the HMAC key. It should contain at least 16 bytes
// and should be generated by a PRNG.
//
// Name is an optional message name that won't be contained in the MACed
// messaged itself but will be MACed against.
type MACConfig struct {
	Name   string
	MaxAge time.Duration
	MaxLen int
}

// EncodeAuthMessage associates the given value with a message authentication
// code for integrity and authenticity.
//
// If the value, when base64 encoded with a fixed size header is longer than
// the configured maximum length, it will panic.
//
// Message format (name prefix is in MAC but removed from message):
//
//  <---------------- MAC input ---------------->
//                           <---------- Message ---------->
//  | name | additional data |    time |  value  |     hmac |
//  | ---- |       ---       | 8 bytes |   ---   | 32 bytes |
//
func EncodeAuthMessage(c MACConfig, key, value, additionalData []byte) ([]byte, error) {
	// Create message with MAC
	sizeHidden := len(c.Name) + len(additionalData)
	sizeMessageAndMAC := timeLen + len(value) + macLen
	size := sizeHidden + sizeMessageAndMAC

	buf := make([]byte, 0, size)

	// Append name and additional data if any
	if len(c.Name) > 0 {
		buf = append(buf, []byte(c.Name)...)
	}
	if len(additionalData) > 0 {
		buf = append(buf, additionalData...)
	}

	// Append timestamp.
	// Increase the len of the buffer of 8 bytes; its capacity allows it.
	buf = buf[:len(buf)+timeLen]
	binary.BigEndian.PutUint64(buf[len(buf)-timeLen:], uint64(Timestamp()))

	// Append value if any
	if len(value) > 0 {
		buf = append(buf, value...)
	}

	// Append MAC signature
	buf = append(buf, createMAC(key, buf)...)

	// Skip name
	buf = buf[sizeHidden:]

	// Check length
	if c.MaxLen > 0 {
		if base64.RawURLEncoding.EncodedLen(len(buf)) > c.MaxLen {
			panic("the value is too long")
		}
	}

	// Encode to base64
	return Base64Encode(buf), nil
}

// DecodeAuthMessage verifies a message authentified with message
// authentication code and returns the message value algon with the issued time
// of the message.
func DecodeAuthMessage(c MACConfig, key, enc, additionalData []byte) ([]byte, error) {
	// Check length
	if c.MaxLen > 0 {
		if len(enc) > c.MaxLen {
			return nil, errMACTooLong
		}
	}

	// Decode from base64
	if base64.RawURLEncoding.DecodedLen(len(enc)) < macLen+timeLen {
		return nil, errMACInvalid
	}
	dec, err := Base64Decode(enc)
	if err != nil {
		return nil, err
	}

	// Prepend name and additional data
	if len(c.Name) > 0 {
		additionalData = append([]byte(c.Name), additionalData...)
	}
	if len(additionalData) > 0 {
		dec = append(additionalData, dec...)
	}

	// Verify message with MAC
	{
		var mac = dec[len(dec)-macLen:]
		dec = dec[:len(dec)-macLen]
		if !verifyMAC(key, dec, mac) {
			return nil, errMACInvalid
		}
	}

	// Skip name prefix
	buf := bytes.NewBuffer(dec)
	if len(additionalData) > 0 {
		buf.Next(len(additionalData))
	}

	// Read time and verify time ranges
	timeBuf := buf.Next(timeLen)
	if c.MaxAge != 0 {
		t := time.Unix(int64(binary.BigEndian.Uint64(timeBuf)), 0)
		if t.Add(c.MaxAge).Before(time.Now()) {
			return nil, errMACExpired
		}
	}

	// Returns the value
	return buf.Bytes(), nil
}

// createMAC creates a MAC with HMAC-SHA256
func createMAC(key, value []byte) []byte {
	mac := hmac.New(sha256.New, key)
	mac.Write(value)
	return mac.Sum(nil)
}

// verifyMAC returns true is the MAC is valid
func verifyMAC(key, value []byte, mac []byte) bool {
	expectedMAC := createMAC(key, value)
	return hmac.Equal(mac, expectedMAC)
}
