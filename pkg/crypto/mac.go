package crypto

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"errors"
)

var (
	errMACTooLong = errors.New("mac: too long")
	errMACExpired = errors.New("mac: expired")
	errMACInvalid = errors.New("mac: the value is not valid")
)

const (
	macLen  = 32
	timeLen = 8
)

// MACConfig contains all the options to encode or decode a message along with
// a proof of integrity and authenticity.
//
// Key is the secret used for the HMAC key. It should contain at least 16 bytes
// and should be generated by a PRNG.
//
// Name is an optional message name that won't be contained in the MACed
// messaged itself but will be MACed against.
type MACConfig struct {
	Key    []byte
	Name   string
	MaxAge int64
	MaxLen int
}

func assertMACConfig(c *MACConfig) {
	if c.Key == nil {
		panic("hash key is not set")
	}
	if len(c.Key) < 16 {
		panic("hash key is not long enough")
	}
}

// EncodeAuthMessage associates the given value with a message authentication
// code for integrity and authenticity.
//
// If the value, when base64 encoded with a fixed size header is longer than
// the configured maximum length, it will panic.
//
// Message format (name prefix is in MAC but removed from message):
//
//  <---------------- MAC input ---------------->
//                           <---------- Message ---------->
//  | name | additional data |    time |  value  |     hmac |
//  | ---- |       ---       | 8 bytes |   ---   | 32 bytes |
//
func EncodeAuthMessage(c *MACConfig, value, additionalData []byte) ([]byte, error) {
	assertMACConfig(c)

	// Create byte slice with big endian representation of timestamp
	timeBuf := make([]byte, timeLen)
	binary.BigEndian.PutUint64(timeBuf, uint64(Timestamp()))

	// Create message with MAC
	sizeHidden := len(c.Name) + len(additionalData)
	sizeMessageAndMAC := timeLen + len(value) + macLen
	size := sizeHidden + sizeMessageAndMAC

	buf := bytes.NewBuffer(make([]byte, 0, size))
	buf.Write([]byte(c.Name))
	buf.Write(additionalData)
	buf.Write(timeBuf)
	buf.Write(value)

	// Append mac
	buf.Write(createMAC(c.Key, buf.Bytes()))

	// Skip name
	buf.Next(sizeHidden)

	// Check length
	if c.MaxLen > 0 {
		if base64.RawURLEncoding.EncodedLen(buf.Len()) > c.MaxLen {
			panic("the value is too long")
		}
	}

	// Encode to base64
	return Base64Encode(buf.Bytes()), nil
}

// DecodeAuthMessage verifies a message authentified with message
// authentication code and returns the message value algon with the issued time
// of the message.
func DecodeAuthMessage(c *MACConfig, enc, additionalData []byte) ([]byte, error) {
	assertMACConfig(c)

	// Check length
	if c.MaxLen > 0 {
		if len(enc) > c.MaxLen {
			return nil, errMACTooLong
		}
	}

	// Decode from base64
	dec, err := Base64Decode(enc)
	if err != nil {
		return nil, err
	}
	if len(dec) < macLen {
		return nil, errMACInvalid
	}

	// Prepend name and additional data
	if len(c.Name) > 0 {
		additionalData = append([]byte(c.Name), additionalData...)
	}
	if len(additionalData) > 0 {
		dec = append(additionalData, dec...)
	}

	// Verify message with MAC
	{
		var mac = dec[len(dec)-macLen:]
		dec = dec[:len(dec)-macLen]
		if !verifyMAC(c.Key, dec, mac) {
			return nil, errMACInvalid
		}
	}

	// Skip name prefix
	buf := bytes.NewBuffer(dec)
	if len(additionalData) > 0 {
		buf.Next(len(additionalData))
	}

	// Read time and verify time ranges
	timeBuf := buf.Next(timeLen)
	if c.MaxAge != 0 {
		time := int64(binary.BigEndian.Uint64(timeBuf))
		if time < Timestamp()-c.MaxAge {
			return nil, errMACExpired
		}
	}

	// Returns the value
	return buf.Bytes(), nil
}

// createMAC creates a MAC with HMAC-SHA256
func createMAC(key, value []byte) []byte {
	mac := hmac.New(sha256.New, key)
	mac.Write(value)
	return mac.Sum(nil)
}

// verifyMAC returns true is the MAC is valid
func verifyMAC(key, value []byte, mac []byte) bool {
	expectedMAC := createMAC(key, value)
	return hmac.Equal(mac, expectedMAC)
}
